"""
Tool: plot_general
Generated by Tool Builder Agent

Creates common visualizations for experimental data including scatter/line plots, correlation matrices, and 2D heatmaps/response surfaces. Accepts dataset names and flexible plotting parameters. Automatically infers appropriate columns when not specified and provides helpful guidance for ambiguous inputs. Saves plots as image files to the output directory.

Examples:
1. plot_general('experiment_data', 'scatter', 'results_scatter', x='temperature', y='yield', hue='catalyst')
# Creates scatter plot of yield vs temperature colored by catalyst type
2. plot_general('sensor_readings', 'heatmap', 'sensor_heatmap', x='time', y='location', z='value', agg='mean')
# Creates heatmap showing average sensor values across time and location

Data Inputs: dataset (string): Name of dataset to visualize, or CSV string, or dict-like object
kind (string): Plot type - 'scatter', 'line', 'matrix', or 'heatmap'
out_dataset (string): Name for saved plot artifacts
x, y, z (string, optional): Column names for axes/values
hue (string, optional): Column for color grouping
facets (string, optional): Column for subplot faceting
agg (string): Aggregation method for heatmaps ('mean', 'sum', 'count')
method (string): Plotting backend ('auto', 'seaborn', 'matplotlib')
Data Outputs: Saves plot images to output directory as PNG files
Returns descriptive string about the generated visualization
"""

import numpy as np
import pandas as pd
import pyarrow as pa
from typing import Any

# Tool implementation
def plot_general(dataset, kind, out_dataset, x=None, y=None, z=None, hue=None, facets=None, agg='mean', method='auto', *, db, config) -> str:
    """
    Creates common visualizations for experimental data.
    
    Args:
        dataset: Dataset name (string) to visualize
        kind: Plot type - 'scatter', 'line', 'matrix', or 'heatmap'
        out_dataset: Name for saved plot artifacts
        x: Column name for x-axis (auto-inferred if None)
        y: Column name for y-axis (auto-inferred if None) 
        z: Column name for z-axis/color values (for heatmaps)
        hue: Column name for color grouping
        facets: Column name for subplot faceting
        agg: Aggregation method for heatmaps ('mean', 'sum', 'count', etc.)
        method: Plotting method ('auto', 'seaborn', 'matplotlib', 'plotly')
    
    Returns:
        String description of the generated plot and save location
    """
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    import seaborn as sns
    import os
    from pathlib import Path
    
    try:
        # Load dataset
        try:
            if isinstance(dataset, str) and dataset in db.list_tables():
                df = db.get_table(dataset).to_pandas()
            elif isinstance(dataset, str):
                # Try to parse as CSV string
                from io import StringIO
                df = pd.read_csv(StringIO(dataset))
            elif isinstance(dataset, dict):
                df = pd.DataFrame(dataset)
            else:
                df = pd.DataFrame(dataset)
        except Exception as e:
            return f"Error loading dataset '{dataset}': {str(e)}. Please provide a valid dataset name, CSV string, or dict-like object."
        
        if df.empty:
            return f"Dataset '{dataset}' is empty. Cannot create visualization."
        
        # Validate kind parameter
        valid_kinds = ['scatter', 'line', 'matrix', 'heatmap']
        if kind not in valid_kinds:
            return f"Invalid plot kind '{kind}'. Must be one of: {valid_kinds}"
        
        # Get numeric and categorical columns
        numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
        categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()
        
        # Set up output directory
        output_dir = Path(config.get('output_path', './outputs'))
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Configure plot style
        plt.style.use('default')
        sns.set_palette("husl")
        
        if kind == 'matrix':
            # Correlation matrix
            if len(numeric_cols) < 2:
                return f"Correlation matrix requires at least 2 numeric columns. Found: {numeric_cols}"
            
            corr_data = df[numeric_cols].corr()
            
            plt.figure(figsize=(10, 8))
            mask = np.triu(np.ones_like(corr_data, dtype=bool))
            sns.heatmap(corr_data, mask=mask, annot=True, cmap='coolwarm', center=0,
                       square=True, linewidths=0.5, cbar_kws={"shrink": .8})
            plt.title(f'Correlation Matrix - {dataset}')
            plt.tight_layout()
            
            plot_path = output_dir / f"{out_dataset}_correlation_matrix.png"
            plt.savefig(plot_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return f"Correlation matrix saved to {plot_path}. Analyzed {len(numeric_cols)} numeric variables with {len(df)} data points."
        
        elif kind in ['scatter', 'line']:
            # Infer x and y if not provided
            if x is None:
                if len(numeric_cols) >= 1:
                    x = numeric_cols[0]
                else:
                    return f"No numeric columns found for x-axis. Available columns: {list(df.columns)}"
            
            if y is None:
                if len(numeric_cols) >= 2:
                    y = numeric_cols[1] if numeric_cols[1] != x else numeric_cols[0]
                else:
                    return f"Need at least 2 numeric columns for {kind} plot. Found: {numeric_cols}"
            
            # Validate columns exist
            if x not in df.columns:
                return f"Column '{x}' not found. Available columns: {list(df.columns)}"
            if y not in df.columns:
                return f"Column '{y}' not found. Available columns: {list(df.columns)}"
            
            # Create plot
            fig, ax = plt.subplots(figsize=(10, 6))
            
            if facets and facets in df.columns:
                # Create subplot grid
                unique_facets = df[facets].unique()
                n_facets = len(unique_facets)
                cols = min(3, n_facets)
                rows = (n_facets + cols - 1) // cols
                
                fig, axes = plt.subplots(rows, cols, figsize=(5*cols, 4*rows))
                if n_facets == 1:
                    axes = [axes]
                elif rows == 1:
                    axes = axes.flatten()
                else:
                    axes = axes.flatten()
                
                for i, facet_val in enumerate(unique_facets):
                    if i < len(axes):
                        subset = df[df[facets] == facet_val]
                        if kind == 'scatter':
                            if hue and hue in df.columns:
                                for hue_val in subset[hue].unique():
                                    hue_subset = subset[subset[hue] == hue_val]
                                    axes[i].scatter(hue_subset[x], hue_subset[y], label=hue_val, alpha=0.7)
                                axes[i].legend()
                            else:
                                axes[i].scatter(subset[x], subset[y], alpha=0.7)
                        else:  # line
                            if hue and hue in df.columns:
                                for hue_val in subset[hue].unique():
                                    hue_subset = subset[subset[hue] == hue_val].sort_values(x)
                                    axes[i].plot(hue_subset[x], hue_subset[y], label=hue_val, marker='o')
                                axes[i].legend()
                            else:
                                subset_sorted = subset.sort_values(x)
                                axes[i].plot(subset_sorted[x], subset_sorted[y], marker='o')
                        
                        axes[i].set_xlabel(x)
                        axes[i].set_ylabel(y)
                        axes[i].set_title(f'{facets} = {facet_val}')
                
                # Hide empty subplots
                for i in range(n_facets, len(axes)):
                    axes[i].set_visible(False)
                    
            else:
                # Single plot
                if kind == 'scatter':
                    if hue and hue in df.columns:
                        for hue_val in df[hue].unique():
                            hue_subset = df[df[hue] == hue_val]
                            ax.scatter(hue_subset[x], hue_subset[y], label=hue_val, alpha=0.7)
                        ax.legend()
                    else:
                        ax.scatter(df[x], df[y], alpha=0.7)
                else:  # line
                    if hue and hue in df.columns:
                        for hue_val in df[hue].unique():
                            hue_subset = df[df[hue] == hue_val].sort_values(x)
                            ax.plot(hue_subset[x], hue_subset[y], label=hue_val, marker='o')
                        ax.legend()
                    else:
                        df_sorted = df.sort_values(x)
                        ax.plot(df_sorted[x], df_sorted[y], marker='o')
                
                ax.set_xlabel(x)
                ax.set_ylabel(y)
            
            plt.suptitle(f'{kind.title()} Plot - {dataset}')
            plt.tight_layout()
            
            plot_path = output_dir / f"{out_dataset}_{kind}_plot.png"
            plt.savefig(plot_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            hue_info = f" grouped by {hue}" if hue else ""
            facet_info = f" faceted by {facets}" if facets else ""
            return f"{kind.title()} plot of {y} vs {x}{hue_info}{facet_info} saved to {plot_path}. Plotted {len(df)} data points."
        
        elif kind == 'heatmap':
            # 2D heatmap/response surface
            if x is None or y is None:
                if len(numeric_cols) >= 2:
                    x = x or numeric_cols[0]
                    y = y or numeric_cols[1]
                else:
                    return f"Heatmap requires x and y columns. Available numeric columns: {numeric_cols}"
            
            if z is None:
                # Try to infer target column
                remaining_numeric = [col for col in numeric_cols if col not in [x, y]]
                if remaining_numeric:
                    z = remaining_numeric[0]
                else:
                    return f"Heatmap requires z column for values. Available columns: {list(df.columns)}"
            
            # Validate columns
            for col, name in [(x, 'x'), (y, 'y'), (z, 'z')]:
                if col not in df.columns:
                    return f"Column '{col}' for {name} not found. Available columns: {list(df.columns)}"
            
            # Create pivot table with aggregation
            try:
                pivot_data = df.pivot_table(values=z, index=y, columns=x, aggfunc=agg)
            except Exception as e:
                return f"Error creating heatmap pivot: {str(e)}. Try different x/y columns or aggregation method."
            
            plt.figure(figsize=(12, 8))
            sns.heatmap(pivot_data, annot=True, fmt='.2f', cmap='viridis', cbar_kws={'label': z})
            plt.title(f'Heatmap - {z} by {x} and {y} ({agg})')
            plt.xlabel(x)
            plt.ylabel(y)
            plt.tight_layout()
            
            plot_path = output_dir / f"{out_dataset}_heatmap.png"
            plt.savefig(plot_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            return f"Heatmap of {z} ({agg}) by {x} and {y} saved to {plot_path}. Grid size: {pivot_data.shape}"
        
    except Exception as e:
        return f"Error creating {kind} plot: {str(e)}. Please check your data and parameters."

# Tool metadata for registration
TOOL_METADATA = {'name': 'plot_general', 'description': 'Creates common visualizations for experimental data including scatter/line plots, correlation matrices, and 2D heatmaps/response surfaces. Accepts dataset names and flexible plotting parameters. Automatically infers appropriate columns when not specified and provides helpful guidance for ambiguous inputs. Saves plots as image files to the output directory.', 'examples': ["plot_general('experiment_data', 'scatter', 'results_scatter', x='temperature', y='yield', hue='catalyst')\n# Creates scatter plot of yield vs temperature colored by catalyst type", "plot_general('sensor_readings', 'heatmap', 'sensor_heatmap', x='time', y='location', z='value', agg='mean')\n# Creates heatmap showing average sensor values across time and location"], 'data_inputs': "dataset (string): Name of dataset to visualize, or CSV string, or dict-like object\nkind (string): Plot type - 'scatter', 'line', 'matrix', or 'heatmap'\nout_dataset (string): Name for saved plot artifacts\nx, y, z (string, optional): Column names for axes/values\nhue (string, optional): Column for color grouping\nfacets (string, optional): Column for subplot faceting\nagg (string): Aggregation method for heatmaps ('mean', 'sum', 'count')\nmethod (string): Plotting backend ('auto', 'seaborn', 'matplotlib')", 'data_outputs': 'Saves plot images to output directory as PNG files\nReturns descriptive string about the generated visualization'}
