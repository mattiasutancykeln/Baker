"""
Tool: chem_similarity
Generated by Tool Builder Agent

Computes molecular similarity on fingerprints derived from SMILES and saves results to out_dataset. Accepts dataset and ref_dataset as dataset names. Accepts smiles_cols as string or list (alias: smiles_col). If ref_dataset is provided, computes similarity against the reference set; otherwise, computes all-vs-all. If cluster=True, performs simple clustering (e.g., Butina) and includes cluster labels. If threshold is provided, optionally saves a long-form pair list above the threshold to keep artifacts manageable; otherwise warns when matrices are very large. Returns a concise text summary with basic stats and guidance if SMILES columns are ambiguous.

Examples:
1. chem_similarity('compounds', 'smiles', 'similarity_matrix', method='tanimoto', threshold=0.7)
# Computes Tanimoto similarities for all compound pairs above 0.7 threshold
2. chem_similarity('test_compounds', 'canonical_smiles', 'clustered_similarity', cluster=True, cluster_method='butina', threshold=0.8)
# Computes similarities and performs Butina clustering with 0.8 similarity threshold

Data Inputs: dataset (string): Name of input dataset containing SMILES
smiles_cols (string or list): Column name(s) containing SMILES strings
ref_dataset (string, optional): Name of reference dataset for comparison
Data Outputs: out_dataset: Similarity matrix or pairwise similarities
{out_dataset}_clusters (if cluster=True): Cluster assignments for molecules
"""

import numpy as np
import pandas as pd
import pyarrow as pa
from typing import Any

# Tool implementation
def chem_similarity(dataset, smiles_cols, out_dataset, method='tanimoto', ref_dataset=None, threshold=None, cluster=False, cluster_method='butina', *, db, config) -> str:
    """
    Compute molecular similarity on fingerprints derived from SMILES.
    
    Args:
        dataset: Name of the input dataset
        smiles_cols: Column name(s) containing SMILES strings (string or list)
        out_dataset: Name for the output dataset
        method: Similarity method ('tanimoto', 'dice', 'cosine')
        ref_dataset: Optional reference dataset name for comparison
        threshold: Optional similarity threshold for filtering results
        cluster: Whether to perform clustering on similarity matrix
        cluster_method: Clustering method ('butina', 'ward', 'complete')
    
    Returns:
        String summary of the similarity computation results
    """
    try:
        from rdkit import Chem
        from rdkit.Chem import rdMolDescriptors
        from rdkit import DataStructs
        import numpy as np
        import pandas as pd
        from scipy.cluster.hierarchy import linkage, fcluster
        from scipy.spatial.distance import squareform
        import warnings
        
        # Load input dataset
        try:
            data = db.get_table(dataset).to_pandas()
        except Exception as e:
            return f"Error loading dataset '{dataset}': {str(e)}"
        
        # Handle smiles_cols parameter (accept both smiles_col and smiles_cols)
        if isinstance(smiles_cols, str):
            smiles_cols = [smiles_cols]
        elif smiles_cols is None:
            # Try to find SMILES columns automatically
            potential_cols = [col for col in data.columns if 'smiles' in col.lower()]
            if len(potential_cols) == 1:
                smiles_cols = potential_cols
            elif len(potential_cols) > 1:
                return f"Multiple potential SMILES columns found: {potential_cols}. Please specify smiles_cols explicitly."
            else:
                return "No SMILES columns found. Please specify smiles_cols parameter."
        
        # Validate SMILES columns exist
        missing_cols = [col for col in smiles_cols if col not in data.columns]
        if missing_cols:
            return f"SMILES columns not found in dataset: {missing_cols}"
        
        # Use first SMILES column for computation
        smiles_col = smiles_cols[0]
        if len(smiles_cols) > 1:
            warnings.warn(f"Multiple SMILES columns provided. Using '{smiles_col}' for similarity computation.")
        
        # Load reference dataset if provided
        ref_data = None
        if ref_dataset:
            try:
                ref_data = db.get_table(ref_dataset).to_pandas()
                if smiles_col not in ref_data.columns:
                    return f"SMILES column '{smiles_col}' not found in reference dataset"
            except Exception as e:
                return f"Error loading reference dataset '{ref_dataset}': {str(e)}"
        
        # Generate molecular fingerprints
        def smiles_to_fingerprint(smiles_str):
            try:
                mol = Chem.MolFromSmiles(str(smiles_str))
                if mol is None:
                    return None
                return rdMolDescriptors.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
            except:
                return None
        
        # Compute fingerprints for main dataset
        data['fingerprint'] = data[smiles_col].apply(smiles_to_fingerprint)
        valid_fps = data.dropna(subset=['fingerprint'])
        invalid_count = len(data) - len(valid_fps)
        
        if len(valid_fps) == 0:
            return f"No valid SMILES found in column '{smiles_col}'"
        
        # Compute fingerprints for reference dataset if provided
        if ref_data is not None:
            ref_data['fingerprint'] = ref_data[smiles_col].apply(smiles_to_fingerprint)
            ref_valid_fps = ref_data.dropna(subset=['fingerprint'])
            ref_invalid_count = len(ref_data) - len(ref_valid_fps)
            
            if len(ref_valid_fps) == 0:
                return f"No valid SMILES found in reference dataset column '{smiles_col}'"
        
        # Choose similarity function
        if method.lower() == 'tanimoto':
            sim_func = DataStructs.TanimotoSimilarity
        elif method.lower() == 'dice':
            sim_func = DataStructs.DiceSimilarity
        elif method.lower() == 'cosine':
            sim_func = DataStructs.CosineSimilarity
        else:
            return f"Unsupported similarity method: {method}. Use 'tanimoto', 'dice', or 'cosine'"
        
        # Compute similarity matrix
        if ref_data is not None:
            # Dataset vs reference comparison
            n_query = len(valid_fps)
            n_ref = len(ref_valid_fps)
            
            similarities = []
            for i, (idx1, row1) in enumerate(valid_fps.iterrows()):
                for j, (idx2, row2) in enumerate(ref_valid_fps.iterrows()):
                    sim = sim_func(row1['fingerprint'], row2['fingerprint'])
                    if threshold is None or sim >= threshold:
                        similarities.append({
                            'query_idx': idx1,
                            'ref_idx': idx2,
                            'similarity': sim
                        })
            
            result_df = pd.DataFrame(similarities)
            summary = f"Computed {len(similarities)} similarity pairs between {n_query} query and {n_ref} reference molecules"
            
        else:
            # All-vs-all comparison
            n_mols = len(valid_fps)
            
            if n_mols > 1000 and threshold is None:
                warnings.warn(f"Large similarity matrix ({n_mols}x{n_mols}). Consider setting a threshold to reduce output size.")
            
            similarities = []
            fps_list = list(valid_fps['fingerprint'])
            indices = list(valid_fps.index)
            
            for i in range(n_mols):
                for j in range(i+1, n_mols):
                    sim = sim_func(fps_list[i], fps_list[j])
                    if threshold is None or sim >= threshold:
                        similarities.append({
                            'mol1_idx': indices[i],
                            'mol2_idx': indices[j],
                            'similarity': sim
                        })
            
            result_df = pd.DataFrame(similarities)
            
            # Perform clustering if requested
            if cluster and len(similarities) > 0:
                # Create distance matrix for clustering
                sim_matrix = np.zeros((n_mols, n_mols))
                for _, row in result_df.iterrows():
                    i = indices.index(row['mol1_idx'])
                    j = indices.index(row['mol2_idx'])
                    sim_matrix[i, j] = row['similarity']
                    sim_matrix[j, i] = row['similarity']
                
                # Fill diagonal with 1.0
                np.fill_diagonal(sim_matrix, 1.0)
                
                # Convert to distance matrix
                dist_matrix = 1 - sim_matrix
                
                if cluster_method.lower() == 'butina':
                    # Simple Butina-like clustering based on similarity threshold
                    cluster_threshold = threshold if threshold else 0.7
                    clusters = []
                    unclustered = set(range(n_mols))
                    cluster_id = 0
                    
                    while unclustered:
                        # Find molecule with most neighbors above threshold
                        best_mol = None
                        best_neighbors = []
                        
                        for mol in unclustered:
                            neighbors = [j for j in unclustered if j != mol and sim_matrix[mol, j] >= cluster_threshold]
                            if len(neighbors) > len(best_neighbors):
                                best_mol = mol
                                best_neighbors = neighbors
                        
                        if best_mol is None:
                            # No more clusters possible, assign remaining to individual clusters
                            for mol in unclustered:
                                clusters.append({'mol_idx': indices[mol], 'cluster': cluster_id})
                                cluster_id += 1
                            break
                        
                        # Create cluster
                        cluster_members = [best_mol] + best_neighbors
                        for mol in cluster_members:
                            clusters.append({'mol_idx': indices[mol], 'cluster': cluster_id})
                            unclustered.discard(mol)
                        cluster_id += 1
                    
                    cluster_df = pd.DataFrame(clusters)
                    
                else:
                    # Hierarchical clustering
                    condensed_dist = squareform(dist_matrix)
                    linkage_matrix = linkage(condensed_dist, method=cluster_method)
                    
                    # Determine number of clusters (simple heuristic)
                    n_clusters = max(2, min(10, n_mols // 5))
                    cluster_labels = fcluster(linkage_matrix, n_clusters, criterion='maxclust')
                    
                    cluster_df = pd.DataFrame({
                        'mol_idx': indices,
                        'cluster': cluster_labels
                    })
                
                # Save clustering results
                db.save_table(f"{out_dataset}_clusters", cluster_df)
                n_clusters = len(cluster_df['cluster'].unique())
                summary = f"Computed {len(similarities)} similarity pairs for {n_mols} molecules with {n_clusters} clusters"
            else:
                summary = f"Computed {len(similarities)} similarity pairs for {n_mols} molecules"
        
        # Save results
        if len(result_df) > 0:
            db.save_table(out_dataset, result_df)
            
            # Add statistics to summary
            if len(result_df) > 0:
                mean_sim = result_df.iloc[:, -1].mean()  # Last column should be similarity
                max_sim = result_df.iloc[:, -1].max()
                min_sim = result_df.iloc[:, -1].min()
                summary += f". Similarity stats: mean={mean_sim:.3f}, min={min_sim:.3f}, max={max_sim:.3f}"
        else:
            # Save empty result
            db.save_table(out_dataset, result_df)
            summary += " (no pairs above threshold)" if threshold else " (no valid pairs)"
        
        # Add invalid SMILES info to summary
        if invalid_count > 0:
            summary += f". {invalid_count} invalid SMILES in main dataset"
        if ref_data is not None and ref_invalid_count > 0:
            summary += f", {ref_invalid_count} invalid SMILES in reference dataset"
        
        return summary
        
    except ImportError as e:
        return f"Missing required dependencies: {str(e)}. Please install rdkit-pypi and scipy."
    except Exception as e:
        return f"Error computing molecular similarity: {str(e)}"

# Tool metadata for registration
TOOL_METADATA = {'name': 'chem_similarity', 'description': 'Computes molecular similarity on fingerprints derived from SMILES and saves results to out_dataset. Accepts dataset and ref_dataset as dataset names. Accepts smiles_cols as string or list (alias: smiles_col). If ref_dataset is provided, computes similarity against the reference set; otherwise, computes all-vs-all. If cluster=True, performs simple clustering (e.g., Butina) and includes cluster labels. If threshold is provided, optionally saves a long-form pair list above the threshold to keep artifacts manageable; otherwise warns when matrices are very large. Returns a concise text summary with basic stats and guidance if SMILES columns are ambiguous.', 'examples': ["chem_similarity('compounds', 'smiles', 'similarity_matrix', method='tanimoto', threshold=0.7)\n# Computes Tanimoto similarities for all compound pairs above 0.7 threshold", "chem_similarity('test_compounds', 'canonical_smiles', 'clustered_similarity', cluster=True, cluster_method='butina', threshold=0.8)\n# Computes similarities and performs Butina clustering with 0.8 similarity threshold"], 'data_inputs': 'dataset (string): Name of input dataset containing SMILES\nsmiles_cols (string or list): Column name(s) containing SMILES strings\nref_dataset (string, optional): Name of reference dataset for comparison', 'data_outputs': 'out_dataset: Similarity matrix or pairwise similarities\n{out_dataset}_clusters (if cluster=True): Cluster assignments for molecules'}
