"""
Tool: anova_test
Generated by Tool Builder Agent

Performs ANOVA analysis on specified factors with optional covariates. Supports one-way, two-way, and multi-way ANOVA designs with Type I, II, or III sum of squares. Calculates effect sizes (eta-squared, partial eta-squared) and performs optional post-hoc multiple comparisons (Tukey HSD, Bonferroni, etc.). Handles both balanced and unbalanced designs. Accepts dataset name, factors as list or comma-separated string, and optional covariates. Returns concise statistical summary; optionally saves detailed results table.

Examples:
1. anova_test('experiment_data', 'yield', 'treatment') - One-way ANOVA testing effect of treatment on yield
2. anova_test('clinical_trial', 'recovery_time', ['drug_type', 'age_group'], covariates='baseline_score', posthoc='bonferroni', out_dataset='anova_results') - Two-way ANOVA with covariate and Bonferroni post-hoc tests

Data Inputs: dataset (string): Name of dataset in database containing the data
response (string): Name of the dependent/response variable column
factors (string or list): Factor variable name(s) - categorical predictors
covariates (string or list, optional): Covariate variable name(s) - continuous predictors
type (string, optional): Type of sum of squares ('I', 'II', 'III'), default 'II'
posthoc (string, optional): Post-hoc test method ('tukey', 'bonferroni', 'holm', 'none'), default 'tukey'
alpha (float, optional): Significance level, default 0.05
out_dataset (string, optional): Name to save detailed results table
Data Outputs: Returns string with ANOVA summary including F-statistics, p-values, effect sizes, and post-hoc results if requested. If out_dataset specified, saves detailed results table with all statistics, residuals, and diagnostic information.
"""

import numpy as np
import pandas as pd
import pyarrow as pa
from typing import Any

# Tool implementation
import pandas as pd
import numpy as np
from scipy import stats
from statsmodels.stats.anova import anova_lm
from statsmodels.formula.api import ols
from statsmodels.stats.multicomp import pairwise_tukeyhsd, MultiComparison
from statsmodels.stats.multitest import multipletests
import warnings
warnings.filterwarnings('ignore')

def anova_test(dataset: str, response: str, factors, covariates=None, type='II', posthoc='tukey', alpha=0.05, out_dataset=None, *, db, config) -> str:
    """
    Performs ANOVA analysis with optional covariates and post-hoc tests.
    
    Args:
        dataset: Name of dataset in database
        response: Dependent variable column name
        factors: Factor variable name(s) - can be string or list
        covariates: Optional covariate variable name(s) - can be string or list
        type: Type of sum of squares ('I', 'II', 'III')
        posthoc: Post-hoc test method ('tukey', 'bonferroni', 'holm', 'none')
        alpha: Significance level
        out_dataset: Optional name to save detailed results
    
    Returns:
        String summary of ANOVA results
    """
    
    try:
        # Load dataset
        try:
            data = db.get_table(dataset).to_pandas()
        except Exception as e:
            return f"Error loading dataset '{dataset}': {str(e)}"
        
        # Validate response variable
        if response not in data.columns:
            return f"Error: Response variable '{response}' not found in dataset. Available columns: {list(data.columns)}"
        
        # Process factors
        if isinstance(factors, str):
            if ',' in factors:
                factor_list = [f.strip() for f in factors.split(',')]
            else:
                factor_list = [factors]
        else:
            factor_list = list(factors) if factors else []
        
        # Validate factors
        missing_factors = [f for f in factor_list if f not in data.columns]
        if missing_factors:
            return f"Error: Factor(s) {missing_factors} not found in dataset. Available columns: {list(data.columns)}"
        
        # Process covariates
        covariate_list = []
        if covariates:
            if isinstance(covariates, str):
                if ',' in covariates:
                    covariate_list = [c.strip() for c in covariates.split(',')]
                else:
                    covariate_list = [covariates]
            else:
                covariate_list = list(covariates)
            
            # Validate covariates
            missing_covariates = [c for c in covariate_list if c not in data.columns]
            if missing_covariates:
                return f"Error: Covariate(s) {missing_covariates} not found in dataset. Available columns: {list(data.columns)}"
        
        # Clean data - remove rows with missing values
        all_vars = [response] + factor_list + covariate_list
        clean_data = data[all_vars].dropna()
        
        if len(clean_data) == 0:
            return "Error: No complete cases found after removing missing values"
        
        n_removed = len(data) - len(clean_data)
        if n_removed > 0:
            removal_msg = f"Removed {n_removed} rows with missing values. "
        else:
            removal_msg = ""
        
        # Convert factors to categorical
        for factor in factor_list:
            clean_data[factor] = clean_data[factor].astype('category')
        
        # Build formula
        formula_parts = factor_list.copy()
        if covariate_list:
            formula_parts.extend(covariate_list)
        
        # Add interactions for multiple factors
        if len(factor_list) > 1:
            for i in range(len(factor_list)):
                for j in range(i+1, len(factor_list)):
                    formula_parts.append(f"{factor_list[i]}:{factor_list[j]}")
        
        formula = f"{response} ~ " + " + ".join(formula_parts)
        
        # Fit model
        try:
            model = ols(formula, data=clean_data).fit()
        except Exception as e:
            return f"Error fitting ANOVA model: {str(e)}. Check that factors are categorical and response is numeric."
        
        # Perform ANOVA
        try:
            if type.upper() == 'I':
                anova_table = anova_lm(model, typ=1)
            elif type.upper() == 'III':
                anova_table = anova_lm(model, typ=3)
            else:  # Default to Type II
                anova_table = anova_lm(model, typ=2)
        except Exception as e:
            return f"Error computing ANOVA: {str(e)}"
        
        # Calculate effect sizes (eta-squared and partial eta-squared)
        ss_total = anova_table['sum_sq'].sum()
        anova_table['eta_sq'] = anova_table['sum_sq'] / ss_total
        
        # Partial eta-squared
        ss_error = anova_table.loc['Residual', 'sum_sq'] if 'Residual' in anova_table.index else 0
        anova_table['partial_eta_sq'] = anova_table['sum_sq'] / (anova_table['sum_sq'] + ss_error)
        
        # Build results summary
        results = []
        results.append(f"ANOVA Results for {response}")
        results.append("=" * 50)
        results.append(f"{removal_msg}Analysis based on {len(clean_data)} observations")
        results.append(f"Model: {formula}")
        results.append(f"Type {type.upper()} Sum of Squares")
        results.append("")
        
        # Format ANOVA table
        significant_effects = []
        for idx, row in anova_table.iterrows():
            if idx != 'Residual' and not pd.isna(row['PR(>F)']):
                p_val = row['PR(>F)']
                f_stat = row['F']
                eta_sq = row['eta_sq']
                partial_eta_sq = row['partial_eta_sq']
                
                sig_marker = "***" if p_val < 0.001 else "**" if p_val < 0.01 else "*" if p_val < alpha else ""
                
                results.append(f"{idx}:")
                results.append(f"  F({row['df']:.0f}, {anova_table.loc['Residual', 'df']:.0f}) = {f_stat:.3f}, p = {p_val:.4f} {sig_marker}")
                results.append(f"  η² = {eta_sq:.3f}, partial η² = {partial_eta_sq:.3f}")
                
                if p_val < alpha:
                    significant_effects.append(idx)
                results.append("")
        
        # Model fit statistics
        r_squared = model.rsquared
        adj_r_squared = model.rsquared_adj
        results.append(f"Model R² = {r_squared:.3f}, Adjusted R² = {adj_r_squared:.3f}")
        results.append("")
        
        # Post-hoc tests
        posthoc_results = {}
        if posthoc.lower() != 'none' and significant_effects:
            results.append("Post-hoc Multiple Comparisons:")
            results.append("-" * 35)
            
            for factor in factor_list:
                if factor in significant_effects:
                    try:
                        if posthoc.lower() == 'tukey':
                            mc = MultiComparison(clean_data[response], clean_data[factor])
                            tukey_result = mc.tukeyhsd(alpha=alpha)
                            results.append(f"\nTukey HSD for {factor}:")
                            results.append(str(tukey_result))
                            posthoc_results[factor] = tukey_result
                            
                        elif posthoc.lower() in ['bonferroni', 'holm']:
                            # Pairwise t-tests with correction
                            groups = clean_data[factor].unique()
                            if len(groups) > 1:
                                p_values = []
                                comparisons = []
                                for i in range(len(groups)):
                                    for j in range(i+1, len(groups)):
                                        group1_data = clean_data[clean_data[factor] == groups[i]][response]
                                        group2_data = clean_data[clean_data[factor] == groups[j]][response]
                                        _, p_val = stats.ttest_ind(group1_data, group2_data)
                                        p_values.append(p_val)
                                        comparisons.append(f"{groups[i]} vs {groups[j]}")
                                
                                # Apply correction
                                if posthoc.lower() == 'bonferroni':
                                    corrected_p = multipletests(p_values, method='bonferroni')[1]
                                else:  # holm
                                    corrected_p = multipletests(p_values, method='holm')[1]
                                
                                results.append(f"\n{posthoc.title()} corrected comparisons for {factor}:")
                                for comp, p_orig, p_corr in zip(comparisons, p_values, corrected_p):
                                    sig = "*" if p_corr < alpha else ""
                                    results.append(f"  {comp}: p = {p_corr:.4f} {sig}")
                                
                                posthoc_results[factor] = list(zip(comparisons, corrected_p))
                    
                    except Exception as e:
                        results.append(f"Warning: Could not perform post-hoc tests for {factor}: {str(e)}")
        
        # Save detailed results if requested
        if out_dataset:
            try:
                # Create detailed results dataframe
                detailed_results = pd.DataFrame({
                    'effect': anova_table.index,
                    'sum_sq': anova_table['sum_sq'].values,
                    'df': anova_table['df'].values,
                    'F': anova_table['F'].values,
                    'p_value': anova_table['PR(>F)'].values,
                    'eta_squared': anova_table['eta_sq'].values,
                    'partial_eta_squared': anova_table['partial_eta_sq'].values,
                    'significant': anova_table['PR(>F)'].values < alpha
                })
                
                # Add model diagnostics
                residuals = model.resid
                fitted_values = model.fittedvalues
                
                diagnostics = pd.DataFrame({
                    'fitted_values': fitted_values,
                    'residuals': residuals,
                    'standardized_residuals': residuals / np.std(residuals)
                })
                
                # Save both tables
                db.save_table(f"{out_dataset}_anova", detailed_results)
                db.save_table(f"{out_dataset}_diagnostics", diagnostics)
                
                results.append(f"\nDetailed results saved to '{out_dataset}_anova' and '{out_dataset}_diagnostics'")
                
            except Exception as e:
                results.append(f"\nWarning: Could not save detailed results: {str(e)}")
        
        return "\n".join(results)
        
    except Exception as e:
        return f"Unexpected error in ANOVA analysis: {str(e)}"

# Tool metadata for registration
TOOL_METADATA = {'name': 'anova_test', 'description': 'Performs ANOVA analysis on specified factors with optional covariates. Supports one-way, two-way, and multi-way ANOVA designs with Type I, II, or III sum of squares. Calculates effect sizes (eta-squared, partial eta-squared) and performs optional post-hoc multiple comparisons (Tukey HSD, Bonferroni, etc.). Handles both balanced and unbalanced designs. Accepts dataset name, factors as list or comma-separated string, and optional covariates. Returns concise statistical summary; optionally saves detailed results table.', 'examples': ["anova_test('experiment_data', 'yield', 'treatment') - One-way ANOVA testing effect of treatment on yield", "anova_test('clinical_trial', 'recovery_time', ['drug_type', 'age_group'], covariates='baseline_score', posthoc='bonferroni', out_dataset='anova_results') - Two-way ANOVA with covariate and Bonferroni post-hoc tests"], 'data_inputs': "dataset (string): Name of dataset in database containing the data\nresponse (string): Name of the dependent/response variable column\nfactors (string or list): Factor variable name(s) - categorical predictors\ncovariates (string or list, optional): Covariate variable name(s) - continuous predictors\ntype (string, optional): Type of sum of squares ('I', 'II', 'III'), default 'II'\nposthoc (string, optional): Post-hoc test method ('tukey', 'bonferroni', 'holm', 'none'), default 'tukey'\nalpha (float, optional): Significance level, default 0.05\nout_dataset (string, optional): Name to save detailed results table", 'data_outputs': 'Returns string with ANOVA summary including F-statistics, p-values, effect sizes, and post-hoc results if requested. If out_dataset specified, saves detailed results table with all statistics, residuals, and diagnostic information.'}
